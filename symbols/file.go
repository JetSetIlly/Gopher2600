// This file is part of Gopher2600.
//
// Gopher2600 is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Gopher2600 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Gopher2600.  If not, see <https://www.gnu.org/licenses/>.

package symbols

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strconv"
	"strings"
	"unicode"

	"github.com/jetsetilly/gopher2600/curated"
	"github.com/jetsetilly/gopher2600/hardware/memory/cartridge"
	"github.com/jetsetilly/gopher2600/hardware/memory/memorymap"
)

// ReadSymbolsFile initialises a symbols table from the symbols file for the
// specified cartridge
//
// Symbols instance will always be valid even if error is returned. for example,
// if the symbols file cannot be opened the symbols file will still contain the
// canonical vcs symbols file
//
// Currently, only symbols files generated by DASM are supported.
func ReadSymbolsFile(cart *cartridge.Cartridge) (*Symbols, error) {
	sym := NewSymbols()

	// prefer default symbol for an address over any symbol that has been
	// specified in the symbols file. we always do this even in the event of
	// there being no symbols file.
	defer sym.canonise(cart)

	// if this is the empty cartridge then this error is expected. return
	// the empty symbol table
	if cart.Filename == "" {
		return sym, nil
	}

	// try to open symbols file
	symFilename := cart.Filename
	ext := path.Ext(symFilename)

	// try to figure out the case of the file extension
	if ext == ".BIN" {
		symFilename = fmt.Sprintf("%s.SYM", symFilename[:len(symFilename)-len(ext)])
	} else {
		symFilename = fmt.Sprintf("%s.sym", symFilename[:len(symFilename)-len(ext)])
	}

	sf, err := os.Open(symFilename)
	if err != nil {
		return sym, curated.Errorf("symbols: file not available (%s)", cart.Filename)
	}
	defer sf.Close()

	data, err := ioutil.ReadAll(sf)
	if err != nil {
		return nil, curated.Errorf("symbols: processing error: %v", err)
	}
	lines := strings.Split(string(data), "\n")

	// find interesting lines in the symbols file and add to the Symbols
	// instance.
	for _, ln := range lines {
		// ignore uninteresting lines
		p := strings.Fields(ln)
		if len(p) < 2 || p[0] == "---" {
			continue // for loop
		}

		// get address
		address, err := strconv.ParseUint(p[1], 16, 16)
		if err != nil {
			continue // for loop
		}

		// get symbol
		symbol := p[0]

		// differentiate between labels and other symbols. this is a little
		// heavy handed, but still, it's better than nothing.
		if unicode.IsDigit(rune(symbol[0])) {
			// if symbol begins with a number and a period then it is a label
			i := strings.Index(symbol, ".")
			if i != -1 {
				ma, _ := memorymap.MapAddress(uint16(address), true)
				sym.Label.add(ma, symbol[i:], false)
			}
		} else {
			// (non-label) symbols are both a read and write symbol.
			// compare to canonical vcs symbols which are specific to a read or
			// write context
			ma, _ := memorymap.MapAddress(uint16(address), true)
			sym.Read.add(ma, symbol, false)
			ma, _ = memorymap.MapAddress(uint16(address), false)
			sym.Write.add(ma, symbol, false)
		}
	}

	return sym, nil
}
