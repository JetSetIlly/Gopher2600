// This file is part of Gopher2600.
//
// Gopher2600 is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Gopher2600 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Gopher2600.  If not, see <https://www.gnu.org/licenses/>.
//
// *** NOTE: all historical versions of this file, as found in any
// git repository, are also covered by the licence, even when this
// notice is not present ***

package symbols

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strconv"
	"strings"
	"unicode"

	"github.com/jetsetilly/gopher2600/errors"
)

// ReadSymbolsFile initialises a symbols table from the symbols file for the
// specified cartridge
//
// Table instance will always be valid even if error is returned. for example,
// if the symbols file cannot be opened the symbols file will still contain the
// canonical vcs symbols file
//
// Currently, only symbols files generated by DASM are supported
func ReadSymbolsFile(cartridgeFilename string) (*Table, error) {
	tbl := &Table{
		Locations: newTable(),
		Read:      newTable(),
		Write:     newTable(),
	}

	// prefer default symbol for an address over any symbol that has been
	// specified in the symbols file
	//
	// deferred function because we want to do this in all instances, even if
	// there is an error with the symbols file.
	defer tbl.canoniseTable(true)

	// if this is the empty cartridge then this error is expected. return
	// the empty symbol table
	if cartridgeFilename == "" {
		return tbl, nil
	}

	// try to open symbols file
	symFilename := cartridgeFilename
	ext := path.Ext(symFilename)

	// try to figure out the case of the file extension
	if ext == ".BIN" {
		symFilename = fmt.Sprintf("%s.SYM", symFilename[:len(symFilename)-len(ext)])
	} else {
		symFilename = fmt.Sprintf("%s.sym", symFilename[:len(symFilename)-len(ext)])
	}

	sf, err := os.Open(symFilename)
	if err != nil {
		return tbl, errors.New(errors.SymbolsFileUnavailable, cartridgeFilename)
	}
	defer func() {
		_ = sf.Close()
	}()

	sym, err := ioutil.ReadAll(sf)
	if err != nil {
		return nil, errors.New(errors.SymbolsFileError, err)
	}
	lines := strings.Split(string(sym), "\n")

	// find interesting lines in the symbols file and add to the Table
	// instance.
	for _, ln := range lines {
		// ignore uninteresting lines
		p := strings.Fields(ln)
		if len(p) < 2 || p[0] == "---" {
			continue // for loop
		}

		// get address
		address, err := strconv.ParseUint(p[1], 16, 16)
		if err != nil {
			continue // for loop
		}

		// get symbol
		symbol := p[0]

		// differentiate between location and other symbols. this is a little
		// heavy handed, but still, it's better than nothing.
		if unicode.IsDigit(rune(symbol[0])) {
			// if symbol begins with a number and a period then it is a location symbol
			i := strings.Index(symbol, ".")
			if i != -1 {
				tbl.Locations.add(uint16(address), symbol[i:], false)
			}
		} else {
			// every non-location symbols is both a read and write symbol.
			// compar to canonical vcs symbols which are specific to a read or
			// write context
			tbl.Read.add(uint16(address), symbol, false)
			tbl.Write.add(uint16(address), symbol, false)
		}
	}

	return tbl, nil
}
