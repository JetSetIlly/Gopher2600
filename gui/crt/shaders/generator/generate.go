// This file is part of Gopher2600.
//
// Gopher2600 is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Gopher2600 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Gopher2600.  If not, see <https://www.gnu.org/licenses/>.

//go:generate go run generate.go

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"sort"
	"strings"
)

const generatedGoFile = "../shaders.go"
const vertexShader = "vertex.glsl"
const fragmentShader = "fragment.glsl"
const glslVersion = `"#version 150"`

func read(filename string) (string, error) {
	vs, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer vs.Close()

	s, err := ioutil.ReadAll(vs)
	if err != nil {
		return "", err
	}

	return string(s), nil
}

func generate(constants constants) (rb bool) {
	// open file
	vs, err := read(vertexShader)
	if err != nil {
		fmt.Printf("error opening vertex shader (%s)", err)
		return false
	}

	fs, err := read(fragmentShader)
	if err != nil {
		fmt.Printf("error opening vertex shader (%s)", err)
		return false
	}

	// create output file (over-writing) if it already exists
	f, err := os.Create(generatedGoFile)
	if err != nil {
		fmt.Printf("error during instruction table generation: %s\n", err)
		return false
	}
	defer func() {
		err := f.Close()
		if err != nil {
			fmt.Printf("error during file close: %s\n", err)
			rb = false
		}
	}()

	output := strings.Builder{}
	output.WriteString("// Code generated by hardware/gui/sdlimgui/shaders/generate.go DO NOT EDIT\n")
	output.WriteString("\npackage shaders\n\n")
	output.WriteString(fmt.Sprintf("const Vertex = %s + `\n%s`\n\n", glslVersion, vs))
	output.WriteString(fmt.Sprintf("const Fragment = %s + `\n%s\n%s`\n", glslVersion, constants.String(), fs))

	_, err = f.WriteString(output.String())
	if err != nil {
		fmt.Printf("error during instruction table generation: %s\n", err)
		return false
	}

	fmt.Println("vertex and fragment shaders generated")

	return true
}

type constants map[string]int

func (c *constants) String() string {
	s := strings.Builder{}

	// sort keys
	keys := make([]string, 0, len(*c))
	for k := range *c {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// output constants in sorted order
	for _, k := range keys {
		s.WriteString(fmt.Sprintf("const int %s = %d;\n", k, (*c)[k]))
	}

	return s.String()
}

func getConstants() (constants, error) {
	fset := token.NewFileSet()
	p, err := parser.ParseFile(fset, "../constants.go", nil, 0)
	if err != nil {
		fmt.Printf("finding constants: %s\n", err)
		return nil, err
	}

	m := make(constants)

	ast.Inspect(p, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.Ident:
			if n.IsExported() {
				if n.Obj.Kind == ast.Con {
					m[n.Obj.Name] = n.Obj.Data.(int)
				}
			}
		}
		return true
	})

	return m, nil
}

func main() {
	constants, err := getConstants()
	if err != nil {
		os.Exit(10)
	}

	if !generate(constants) {
		os.Exit(10)
	}
}
